一、什么是泛型？
    泛型是JDK5中引入的一个新特性，本质上是把参数类型参数化，称之为类型形参。
    泛型分为：①泛型类   ②泛型接口   ③泛型方法
二、为什么要使用泛型？
    (1)提高类型的安全性。
        使用泛型后,将类型的检查从运行期提前到编译期,在编译期进行类型检查,可以更早、更容易地找出因为类型限制而导致的类型转换异常,从而提高程序的可靠性。
    (2)消除强制类型转换。
        使用泛型后,程序会记住当前的类型形参,从而无须对传入的实参值进行强制类型转换,使得代码更加清晰和筒洁,可读性更高。
    (3)提高代码复用性。
        使用泛型后,可以更好地将程序中通用的代码提取出来,在使用时传入不同类型的参数,避免了多次编写相同功能的代码,提高了代码的复用性。
    (4)拥有更高的运行效率。
        使用泛型前,传入的实际参数值作为Object类型传递时,需要进行封箱和拆箱操作,会增加程序运行的开销;使用泛型后,类型形参中都需要使用引用数据类型,即传入的实际参
        数的类型都是对应的引用数据类型,避免了封箱和拆箱操作,减少了程序运行的开销,提高了程序的运行效率。
三、泛型类
    (1)定义：
        定义类时,在类名后加上用尖括号括起来类型形参,这个类就是泛型类。创建泛型类的实例对象时传入不同的类型实参,就可以动态生成任意多个该泛型类的子类。
        在JDK类包中泛型类最典型的应用就是各种容器类,如ArrayList,HashMap等。定义泛型类的格式具体如下:
    (2)例子：
        [访问权限]  class   类名<类型形参变量1,类型形参变量2,…,类型形参变量n>{......}
        比如： public class People<T1,T2>{.....}
    (3)泛型类的两种继承方式：
        ①子类不指明父类的泛型参数
            public class Student extends People<T1,T2>{....}
            子类仍是泛型类
        ②子类指明父类泛型参数
            public class Student extends People<String,Integer>{....}

四、泛型接口
    (1)、定义
        定义泛型接口和定义泛型类的语法格式类似,在接口名称后面加上用尖括号括起来类型形参即可。与集合相关的很多接口也是泛型接口,
        如Collection、List等。定义泛型接口的基本语法格式如下:
        [访问权限] interface 接口名称<类型形参变量>{...}
    (2)、泛型接口的两种实现方式：
        ①使用泛型类实现泛型接口：
            public class People<T> implments Learn<T>{...}
            注：类型参数需要一致
        ②非泛型类实现泛型接口：
            punlic class Student implments Learn<English>{.....}

五、泛型方法
    (1)、定义
        泛型方法是将类型形参的声明放在修饰符和返回值类型之间的方法。在Java程序中，定义泛型方法常用的格式如下:
        [访问权限修饰符]   [static]    [final] <类型形参>  返回值类型 方法名(形参列表)(){}
        注:返回值类型可以是类型参数本身
    (2)注意点
        ①访回权限修饰付(包沽private,public、protected) , static和 final都必须写在类型形参的前面。
        ②返回值类型必须写在类型形参的后面。
        ③泛型方法可以在用泛型类中,也可以用在普通类中。
        ④泛型类中的任何方法本质上都是泛型方法,所以在实际使用中很少会在泛型类中用上面的形式定义泛型方法。
        ⑤类型形参可以用在方法体中修饰局部变量,也可以修饰方法的返回值。
        ⑥泛型方法可以是实例方法(没有用static修饰,也叫非静态方法),也可以是静态方法。
        泛型方法也能提高代码的重用性和程序的安全性。Java语言的编程原则是尽量设计泛型方法解决问题,如果设计泛型方法可以取代整个类的泛型化,就应该优先采用泛型方法。
    (3)泛型方法的使用
        ①对象名|类名.<类型实参>方法名(实参列表);
        ②对象名|类名.方法名(类型实参列表);
        注：推荐使用方式1，便于直观的看出是泛型方法，有利于代码的阅读和维护。

六、关于静态方法和泛型
    结论：
        ①泛型类中的静态方法不可以直接使用类的泛型，而是要写成定义泛型方法的形式。
        ②泛型方法可以是静态的
    原因：
        静态方法随着类的加载而加载，但是类是在实例化对象时可以确定类型，而静态方法必须在加载时确定类型


七、类型通配符
    (1)定义
        通配符就是"?",比如:List<?>是List<String>、List<Object>等各种泛型List的父类。
        可以用于接收两种数据类型，但是读取出来的元素类型是Object。
        注：并不是说List<Object>是List<String>的父类，只是"?"是某种类型的泛型的父类
    (2)注意点
        ①不能用在泛型方法声明上，返回值类型前面<>不能使用?
            public static <?> void test(ArrayList<?> list){}
        ②不能用在泛型类的声明上
            class GenericTypeClass<?>{}
        ③不能用在创建对象上，右边属于创建集合对象
            ArrayList<?> list2 = new ArrayList<?>();

     (3)通配符的上限和下限
          通配符指定上限
            上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即<=
          通配符指定下限
            下限super：使用时指定的类型不能小于操作的类，即>=
          举例：
              <? extends Number> ( 无穷小 , Number]
             只允许泛型为Number及Number子类的引用调用
              <? super Number> [Number ,  无穷大)
             只允许泛型为Number及Number父类的引用调用
              <? extends Comparable>
             只允许泛型为实现Comparable接口的实现类的引用调用

八、泛型间的子父类关系
    ①某种类型的通配符形式是所有该类型泛型的父类
        如：List<?> 是List<Object>、List<String>....的父类
    ②使用同种泛型的子父类具有子父类关系
        如：List<Srting>是ArrayList<String>、LinkedList<String>....的父类
    ③单纯泛型不具有子父类关系
        如：List<Object>不是List<String>的父类
